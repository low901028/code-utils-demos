# GO函数方法
在Go语言中，函数和方法不太一样，有明确的概念区分。其他语言中，比如Java，一般来说，函数就是方法，方法就是函数，但是在Go语言中，函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接收者的；而方法是有接收者的，我们说的方法要么是属于一个结构体的，要么属于一个新定义的类型的。

### 函数
函数和方法，虽然概念不同，但是定义非常相似。函数的定义声明没有接收者，所以我们直接在go文件里，go包之下定义声明即可。
~~~
func main() {
    sum := add(1, 2)
    fmt.Println(sum)
}
func add(a, b int) int { 
   return a + b
}
~~~
例子中，我们定义了add就是一个函数，它的函数签名是func add(a, b int) int,没有接收者，直接定义在go的一个包之下，可以直接调用，比如例子中的main函数调用了add函数。

例子中的这个函数名称是小写开头的add，所以它的作用域只属于所声明的包内使用，不能被其他包使用，如果我们把函数名以大写字母开头，该函数的作用域就大了，可以被其他包调用。这也是Go语言中大小写的用处，比如Java中，就有专门的关键字来声明作用域private、protect、public等。
~~~
/*
 提供的常用库，有一些常用的方法，方便使用
*/package lib

// 一个加法实现// 返回a+b的值
func Add(a, b int) int { 
   return a + b
}
~~~
如上例子中定义的Add方法就可以被其他包调用。

### 方法
方法的声明和函数类似，他们的区别是：方法在定义的时候，会在func和方法名之间增加一个参数，这个参数就是接收者，这样我们定义的这个方法就和接收者绑定在了一起，称之为这个接收者的方法。
~~~
type person struct {
    name string
}
func (p person) String() string{ 
   return "the person name is "+p.name
}
~~~
留意例子中，func和方法名之间增加的参数(p person),这个就是接收者。现在我们说，类型person有了一个String方法，现在我们看下如何使用它。
~~~
func main() {
    p:=person{name:"张三"}
    fmt.Println(p.String())
}
~~~
调用的方法非常简单，使用类型的变量进行调用即可，类型变量和方法之前是一个.操作符，表示要调用这个类型变量的某个方法的意思。

### 值接收者和指针接收者
Go语言里有两种类型的接收者：值接收者和指针接收者。我们上面的例子中，就是使用值类型接收者的示例。
#### 值接收者
使用值类型接收者定义的方法，在调用的时候，使用的其实是值接收者的一个副本，所以对该值的任何操作，不会影响原来的类型变量。
~~~
func main() {
    p:=person{name:"张三"}
    p.modify() //值接收者，修改无效
    fmt.Println(p.String())
}
type person struct {
    name string
}
func (p person) String() string{
    return "the person name is "+p.name
}
func (p person) modify(){
    p.name = "李四"
}
~~~
以上的例子，打印出来的值还是张三，对其进行的修改无效。
#### 指针接收者
如果我们使用一个指针作为接收者，那么就会其作用了，因为指针接收者传递的是一个指向原值指针的副本，指针的副本，指向的还是原来类型的值，所以修改时，同时也会影响原来类型变量的值。
~~~
func main() {
    p:=person{name:"张三"}
    p.modify() //指针接收者，修改有效
    fmt.Println(p.String())
}
type person struct {
    name string
}
func (p person) String() string{ 
   return "the person name is "+p.name
}
func (p *person) modify(){
    p.name = "李四"
}
~~~
只需要改动一下，变成指针的接收者，就可以完成了修改。

在调用方法的时候，传递的接收者本质上都是副本，只不过一个是这个值副本，一是指向这个值指针的副本。指针具有指向原有值的特性，所以修改了指针指向的值，也就修改了原有的值。我们可以简单的理解为值接收者使用的是值的副本来调用方法，而指针接收者使用实际的值来调用方法。

在上面的例子中，有没有发现，我们在调用指针接收者方法的时候，使用的也是一个值的变量，并不是一个指针，如果我们使用下面的也是可以的。
~~~
p:=person{name:"张三"}
(&p).modify() //指针接收者，修改有效
~~~
这样也是可以的。如果我们没有这么强制使用指针进行调用，Go的编译器自动会帮我们取指针，以满足接收者的要求。

同样的，如果是一个值接收者的方法，使用指针也是可以调用的，Go编译器自动会解引用，以满足接收者的要求，比如例子中定义的String()方法，也可以这么调用：
~~~
p:=person{name:"张三"}
fmt.Println((&p).String())
~~~
总之，方法的调用，既可以使用值，也可以使用指针，我们不必要严格的遵守这些，Go语言编译器会帮我们进行自动转义的，这大大方便了我们开发者。

不管是使用值接收者，还是指针接收者，一定要搞清楚类型的本质：对类型进行操作的时候，是要改变当前值，还是要创建一个新值进行返回？这些就可以决定我们是采用值传递，还是指针传递。

### 多值返回
Go语言支持函数方法的多值返回，也就说我们定义的函数方法可以返回多个值，比如标准库里的很多方法，都是返回两个值，第一个是函数需要返回的值，第二个是出错时返回的错误信息，这种的好处，我们的出错异常信息再也不用像Java一样使用一个Exception这么重的方式表示了，非常简洁。
~~~
func main() {
    file, err := os.Open("/usr/tmp")
    if err != nil {
        log.Fatal(err)
        return
    }
    fmt.Println(file)
}
~~~
如果返回的值，我们不想使用，可以使用_进行忽略。
~~~
file, _ := os.Open("/usr/tmp")
~~~
多个值返回的定义也非常简单，看个例子。
~~~
func add(a, b int) (int, error) { 
   return a + b, nil
}
~~~
函数方法声明定义的时候，采用逗号分割，因为时多个返回，还要用括号括起来。返回的值还是使用return 关键字，以逗号分割，和返回的声明的顺序一致。

### 可变参数
函数方法的参数，可以是任意多个，这种我们称之为可以变参数，比如我们常用的fmt.Println()这类函数，可以接收一个可变的参数。
~~~
func main() {
    fmt.Println("1","2","3")
}
~~~
可以变参数，可以是任意多个。我们自己也可以定义可以变参数，可变参数的定义，在类型前加上省略号…即可。
~~~
func main() { 
   print("1","2","3")
}
func print (a ...interface{}){ 
   for _,v:=range a{
        fmt.Print(v)
    }
    fmt.Println()
}
~~~
例子中我们自己定义了一个接受可变参数的函数，效果和fmt.Println()一样。

可变参数本质上是一个数组，所以我们向使用数组一样使用它，比如例子中的 for range 循环。

函数方法还有其他一些知识点，比如painc异常处理，递归等，这些在《Go语言实战》书里也没有介绍，这些基础知识，可以参考Go语言的那本圣经。
